name: Pre-Release Workflow

on:
  push:
    branches: [ "main" ]

jobs:
  version-update:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Get current version from tag or Cargo.toml
      - name: Get current version
        id: get_version
        run: |
          if git tag -l | grep -q "."; then
            VERSION=$(git describe --tags --abbrev=0)
          else
            VERSION=$(grep '^version = ' Cargo.toml | head -n 1 | sed -E 's/version = "(.*)"/\1/')
          fi
          # Normalize version (remove leading "v" if present)
          VERSION=${VERSION#v}
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Current version is: $VERSION"

      # Step 3: Get branch name of the most recently merged PR
      - name: Get branch name of most recently merged PR
        id: get_branch_name
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          API_URL="https://api.github.com/repos/${{ github.repository }}/pulls?state=closed&per_page=1"
          RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$API_URL")

          BRANCH_NAME=$(echo "$RESPONSE" | jq -r '.[0].head.ref')

          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "The most recently merged PR came from branch: $BRANCH_NAME"

      # Step 4: Determine the next version based on branch prefix
      - name: Determine next version
        id: versioning
        run: |
          CURRENT_VERSION="${{ env.VERSION }}"
          
          MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)

          if [[ "${{ env.BRANCH_NAME }}" == breaking/* ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [[ "${{ env.BRANCH_NAME }}" == feature/* ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [[ "${{ env.BRANCH_NAME }}" == bugfix/* ]]; then
            PATCH=$((PATCH + 1))
          fi
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "RELEASE_BRANCH=release/$NEW_VERSION" >> $GITHUB_ENV
          echo "Next version determined: $NEW_VERSION; Release branch: release/$NEW_VERSION"

      # (Optional) Debug: Exit early if main is already updated
      - name: Debug - Show version in main
        run: |
          git fetch origin main
          MAIN_VERSION=$(git show origin/main:package.json | jq -r '.version')
          echo "Version from origin/main: $MAIN_VERSION"

          if [ "$MAIN_VERSION" = "${{ env.NEW_VERSION }}" ]; then
            echo "origin/main is already updated to version $MAIN_VERSION. Exiting."
            exit 0
          fi

      # Step 5: Create or update the release branch without wiping out your new commit
      - name: Create or Update Release Branch
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git fetch origin

          BRANCH="${{ env.RELEASE_BRANCH }}"

          # Check if the branch exists remotely
          if git ls-remote --exit-code --heads origin "$BRANCH"; then
            echo "Release branch exists. Checking out $BRANCH..."
            git checkout "$BRANCH"
            # Ensure it tracks origin/$BRANCH (unset any upstream then set it properly)
            git branch --unset-upstream || true
            git branch --set-upstream-to=origin/"$BRANCH" "$BRANCH"

            git reset --hard origin/main
          else
            echo "Creating new release branch $BRANCH from origin/main..."
            git checkout -B "$BRANCH" origin/main
            git push origin "$BRANCH" --set-upstream --force-with-lease
          fi
          echo "Current upstream: $(git rev-parse --abbrev-ref --symbolic-full-name @{u})"
          echo "Current branch: $(git branch --show-current)"

          git log --oneline -5

      # Step 6: Update version in package.json and Cargo.toml
      - name: Update version files
        run: |
          echo "Updating version files to version ${{ env.NEW_VERSION }}..."
          jq --arg newver "${{ env.NEW_VERSION }}" '.version = $newver' package.json > temp.json && mv temp.json package.json
          
          # Use sed to update Cargo.toml with a flexible regex
          sed -E -i "s/^(version\s*=\s*\").*(\")/\1${{ env.NEW_VERSION }}\2/" Cargo.toml
          echo "Updated package.json:"
          cat package.json
          echo "Updated Cargo.toml (version line):"
          grep "^version" Cargo.toml
        env:
          NEW_VERSION: ${{ env.NEW_VERSION }}

      # Step 7: Commit version updates to the release branch (and add a dummy file to force a diff if needed)
      - name: Commit version updates
        run: |
          git checkout "${{ env.RELEASE_BRANCH }}"
          # Optionally, add a dummy file that forces a diff so the PR always shows changes.
          echo "Release version: ${{ env.NEW_VERSION }} updated at $(date)" > release-info.txt
          git add package.json Cargo.toml release-info.txt
          if ! git diff-index --quiet HEAD --; then
            git commit -m "Update version to ${{ env.NEW_VERSION }}"
            git push origin "${{ env.RELEASE_BRANCH }}" --force-with-lease
            echo "Version update committed and pushed."
          else
            echo "No changes detected in version files."
          fi
          git log --oneline -3

      # Step 8: Create the pull request using the GitHub CLI (ensure gh is available)
      - name: Create pull request
        run: |
          echo "Checking for an existing PR for branch ${{ env.RELEASE_BRANCH }}..."
          existing_pr=$(gh pr list --head "${{ env.RELEASE_BRANCH }}" --base main --state open -q ".[].url")
          if [ -n "$existing_pr" ]; then
            echo "A PR already exists: $existing_pr. Skipping creation."
          else
            echo "No existing PR found, creating a new one for release ${{ env.NEW_VERSION }}..."
            gh pr create -B main -H "${{ env.RELEASE_BRANCH }}" \
              --title "Release ${{ env.NEW_VERSION }}" \
              --body "This pull request prepares the release of version ${{ env.NEW_VERSION }}."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
